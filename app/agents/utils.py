import requests
import logging
from transformers import AutoTokenizer, AutoModelForCausalLM
import os




def generate_llm_response(query, mode="planner", history=None):
    """
    Generates a response using GPT-3.5 and incorporates conversation history.

    Args:
        query (str): The current user query.
        mode (str): The mode of operation (e.g., 'planner', 'questionnaire').
        history (list): List of dictionaries with previous messages.

    Returns:
        str: The response generated by GPT-3.5.
    """
    try:
        # Initialize history if not provided
        if history is None:
            history = []

        # Add the current query to history
        history.append({"role": "user", "content": query})

        # System message for the model
        system_message = {"role": "system", "content": f"You are a helpful travel assistant. Mode: {mode}"}

        # Construct messages
        messages = [system_message] + history

        # Call GPT-3.5 API
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=messages
        )

        # Extract response text
        response_text = response["choices"][0]["message"]["content"]

        # Add the assistant's response to history
        history.append({"role": "assistant", "content": response_text})

        return response_text, history  # Return updated history
    except Exception as e:
        return f"Error: {str(e)}", history


def generate_osrm_directions(itinerary):
    """
    Generates text-based directions using OSRM based on the itinerary.
    """
    try:
        # Construct coordinates for OSRM
        coordinates = ";".join([f"{stop['longitude']},{stop['latitude']}" for stop in itinerary])
        osrm_url = f"{OSRM_BASE_URL}/{coordinates}?overview=full&steps=true"
        response = requests.get(osrm_url)

        if response.status_code == 200:
            data = response.json()
            directions = []
            for step in data["routes"][0]["legs"][0]["steps"]:
                directions.append(step["maneuver"]["instruction"])
            logger.info("Generated directions using OSRM.")
            return directions
        else:
            logger.error(f"Failed to fetch directions from OSRM. Response: {response.text}")
            return ["Could not fetch directions."]
    except Exception as e:
        logger.error(f"Error generating directions: {e}")
        raise


def optimize_itinerary(itinerary, budget):
    """
    Optimizes the given itinerary based on user budget constraints.
    """
    try:
        logger.info(f"Optimizing itinerary based on budget: {budget}")
        optimized_itinerary = []
        for stop in itinerary:
            if stop["cost"] <= budget:
                optimized_itinerary.append(stop)
                budget -= stop["cost"]
            else:
                logger.info(f"Skipping stop '{stop['name']}' due to budget constraints.")
        logger.info(f"Optimized itinerary: {optimized_itinerary}")
        return optimized_itinerary
    except Exception as e:
        logger.error(f"Error optimizing itinerary: {e}")
        raise


def get_attraction_status(city, attraction):
    """
    Fetches the status of an attraction in a given city (mocked data for now).
    """
    try:
        logger.info(f"Fetching status for attraction '{attraction}' in city '{city}'.")
        # Mock data - Replace with an actual API call if needed
        status_data = {
            "Eiffel Tower": "Open",
            "Louvre Museum": "Closed for renovations",
            "Berlin Wall": "Open",
        }
        status = status_data.get(attraction, "Unknown")
        logger.info(f"Status for attraction '{attraction}': {status}")
        return status
    except Exception as e:
        logger.error(f"Error fetching attraction status: {e}")
        raise


def adjust_itinerary(itinerary, adjustments):
    """
    Adjusts the itinerary based on user input.
    """
    try:
        logger.info("Adjusting itinerary based on user input.")
        for adjustment in adjustments:
            action = adjustment.get("action")
            stop = adjustment.get("stop")
            if action == "add":
                itinerary.append(stop)
                logger.info(f"Added stop: {stop}")
            elif action == "remove":
                itinerary = [i for i in itinerary if i["name"] != stop["name"]]
                logger.info(f"Removed stop: {stop['name']}")
        logger.info(f"Adjusted itinerary: {itinerary}")
        return itinerary
    except Exception as e:
        logger.error(f"Error adjusting itinerary: {e}")
        raise

# In-memory storage for user preferences
user_preferences = {}

def save_user_preferences_to_memory(user_id, preferences):
    """
    Save user preferences in memory for quick access.

    Args:
        user_id (str): A unique identifier for the user.
        preferences (dict): A dictionary of user preferences (e.g., destination, budget, interests).

    Returns:
        dict: The stored preferences for the user.
    """
    global user_preferences
    if user_id not in user_preferences:
        user_preferences[user_id] = {}

    # Update user preferences
    user_preferences[user_id].update(preferences)

    return user_preferences[user_id]

def get_user_preferences_from_memory(user_id):
    """
    Retrieve user preferences from memory.

    Args:
        user_id (str): A unique identifier for the user.

    Returns:
        dict: The stored preferences for the user or an empty dictionary if none exist.
    """
    global user_preferences
    return user_preferences.get(user_id, {})
